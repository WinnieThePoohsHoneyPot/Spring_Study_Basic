## 🥸 홈 화면과 레이아웃

- HomeController.java

```java
@Controller
@Slf4j
public class HomeController {

    @RequestMapping("/")
    public String home() {
        log.info("home controller");
        return "home";
    }
}
```

## 🥸 회원 등록

- MemberForm.java

```java
@Getter @Setter
public class MemberForm {
    @NotEmpty(message="회원 이름은 필수 입니다")
    private String name;
    private String city;
    private String street;
    private String zipcode;
}
```

- MemberController

```java
@Controller
@RequiredArgsConstructor
public class MemberController {
    private final MemberService memberService;

    @GetMapping("/members/new")
    public String createForm(Model model) {
        model.addAttribute("memberForm", new MemberForm());
        return "members/createMemberForm";
    }

    // 에러 발생시 result에 에러가 담겨서 코드가 실행됨
    @PostMapping("/members/new")
    public String create(@Valid MemberForm memberForm, BindingResult result) {
        if (result.hasErrors()) {
            return "members/createMember";
        }

        Address address =  new Address(form.getCity(), form.getStreet(), form.getZipcode());

        Member member = new Member();
        member.setName(form.getName());
        member.setAddress(address);

        memberService.join(member);
        return "redirect:/";
    }
}
```

- 단순한 예제의 경우에서는 엔티티와 폼을 매핑해서 사용해도 되지만 실제로는 간단한 데이터만 받지 않기 때문에 폼에 맞는 엔티티로 데이터를 받는 것을 권장

## 🥸 회원 목록 조회

- 정보를 `Model`에 담아서 정보를 html에 전달
- 엔티티는 핵심 비즈니스 로직만 가지고 있고 화면을 위한 로직은 제외
- 화면을 위한 로직은 폼 객체나 DTO를 사용해서 해결
- API를 만들 때 엔티티를 반환하면 안됨
  - 엔티티에 변경이 생겼을 때, API의 스펙도 변경되기 때문에 불안정한 API가 됨
  - 엔티티의 필드가 노출됨

```java
@Controller
@RequiredArgsConstructor
public class MemberController {
    @GetMapping("/members")
    public String list(Model model) {
        List<Member> members = memberService.findMembers();
        model.addAttribute("members", members);
        return "members/memberList";
    }
}
```

## 🥸 상품 등록

- BookForm

```java
@Getter @Setter
public class BookForm {
    private Long id;

    private String name;
    private int price;
    private int stockQuantity;

    private String author;
    private String isbn;
}
```

- ItemController

```java
@Controller
@RequiredArgsConstructor
public class ItemController {
    private final ItemService itemService;

    @GetMapping("/items/new")
    public String createForm(Model model) {
        model.addAttribute("form", new BookForm());
        return "items/createItemForm";
    }

    @PostMapping("/items/new")
    public STring create(BookForm form) {
        Book book = new Book();
        // setter을 제거하는 것이 가장 좋은 설계!!
        book.setName(form.getName());
        book.setPrice(form.getPrice());
        book.setStockQuantity(form.getStockQuantity());
        book.setAuthor(form.getAuthor());
        book.setIsbn(form.getIsbn());

        itemService.saveItem(book);
        return "redirect:/";
    }
}
```

## 🥸 상품 목록

- ItemController

```java
@Controller
@RequiredArgsConstructor
public class ItemController {
    @GetMapping("/items")
    public String list(Model model) {
        List<Item> items = itemService.findItems();
        model.addAttribute("items", items);
        return "items/itemList";
    }
}
```

## 🥸 상품 수정

- ItemController

```java
@Controller
@RequiredArgsConstructor
public class ItemController {
    @GetMapping("items/{itemId}/edit")
    public String updateItemForm(@PathVariable("itemId") Long itemId, Model model) {
        Book item = itemService.findOne(itemId);

        BookForm form = new BookForm();
        form.setId(item.getId());
        form.setPrice(form.getPrice());
        form.setStockQuantity(form.getStockQuantity());
        form.setAuthor(item.getAuthor());
        form.setIsbn(item.getIsbn());

        model.addAttribute("form", form);
        return "items/updateItemForm";
    }

    @PostMapping("items/{itemId}/edit")
    public String updateItem(@ModelAttribute("form") BookForm bookForm) {
        Book book = new Book();
        book.setId(bookForm.getId()); // 아이디 취약점 주의
        book.setName(bookForm.getName());
        book.setPrice(bookForm.getPrice());
        book.setStockQuantity(bookForm.getStockQuantity());
        book.setIsbn(bookForm.getIsbn());

        itemService.saveItem(book);
        return "redirect:/items";
    }
}
```

## 🥸 변경 감지와 병합(merge)

_JPA에서 정말 중요한 내용이니 잘 숙지할 것!_

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class ItemUpdateTest {
    @Autowired
    EntityManager em;

    @Test
    public void updateTest() throws Exception {
        Book book = em.find(Book.class, 1L);

        // TX
        book.setName("asdfasdf");

        //변경 감지 == dirty checking
        // TX commit
    }
}
```

### 준영속 엔티티

- 영속성 컨텍스트가 더는 관리하지 않는 엔티티
- 이미 DB에 저장되어 식별자가 존재하는 경우, 임의로 만들어낸 엔티티도 기존 식별자를 가지고 있으면 준영속 엔티티로 볼 수 있음
- JPA가 기본적으로 변경을 관리하지 않기 때문에 DB에 업데이트가 일어나지 않음

### 준영속 엔티티의 수정 - 변경 감지 기능 사용

- 권장하는 기능
- 트랜잭션 안에서 엔티티를 다시 조회하여 변경할 값을 선택하고 트랜잭션 커밋 시점에 변경 감지(Dirty Checking)이 동작해서 데이터베이스에 UPDATE SQL 실행
- setter로 데이터를 변경하는 것보다, 의미있는 메서드를 설계해서 사용하는 것이 가독성(변경 추적)에서 좋다!

```java
@Transactional
public void updateItem(Long itemId, Book param) {
    // 영속 엔티티의 변경 감지 기능 사용
    Item findItem = itemRepository.findOne(itemId);
    findItem.setPrice(param.getPrice());
    findItem.setName(param.getName());
    findItem.setStockQuantity(param.getStockQuantity());
}
```

### 준영속 엔티티의 수정 - 병합(merge) 사용

- 병합 : 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능

```java
@Transactional
void update(Item itemParam) {
    Item mergeItem = em.merge(item);
}
```

#### 동작방식

1. `merge()` 실행
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티 조회, 만약 1차 캐시에 엔티티가 없다면 DB에서 엔티티를 조회하고 1차 캐시에 저장
3. 조회한 영속 엔티티에 준영속 엔티티 값으로 교체
4. 영속 상태인 조회한 영속 엔티티 반환

#### 주의

- 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경
- 병합시 값이 없으면 `null`로 업데이트 할 위험이 있음

### 가장 좋은 해결 방법

- **엔티티를 변경할 때는 항상 변경 감지 사용**
- 컨트롤러에서 어설프게 엔티티를 생성하지 말 것
- 트랜잭션이 있는 서비스 계층에 식별자와 변경할 데이터를 명확하게 전달(파라미터나 DTO 객체 사용)
- 트랜젝션이 있는 서비스 계층에 영속 상태의 엔티티를 조회하고 엔티티의 데이터 직접 변경
  - 트랜잭션 커밋 시점에 변경 감지 실행

## 🥸 상품 주문

- OrderController

```java
@Controller
@RequiredArgsConstructor
public class OrderController {
    private final OrderService orderService;
    private final MemberService memberService;
    private final ItemService itemService;

    @GetMapping
    public String createForm(Model model) {
        List<Member> members = memberService.findMembers();
        List<Item> items = itemService.findItems();

        model.addAttribute("members", members);
        model.addAttribute("items", items);

        return "order/orderForm";
    }

    @PostMapping("/order")
    public String order(@RequestParam("memberId") Long memberId,
                        @RequestParam("itemId") Long itemId,
                        @RequestParam("count") int count) {
        orderService.order(memberId, itemId, count);
        return "redirect:/orders";
    }
}
```

- 조회가 아닌 핵심 비즈니스 로직은 Controller가 아닌 Service가 하는 것이 좋음

## 🥸 주문 목록 검색, 취소

- OrderSearch

```java
@Getter @Setter
public class OrderSearch {
    private String memberName;
    private OrderStatus orderStatus;
}
```

- OrderService
  - 단순 조회 기능의 경우 구조에 따라 다르지만 위임하지 않고 Controller에서 Repository로 바로 접근해도 괜찮음

```java
@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class OrderService {
    public List<Order> findOrders(OrderSearch orderSearch) {
        return orderRepository.findAllByString(orderSearch);
    }
}
```

- OrderController

```java
@Controller
@RequiredArgsConstructor
public class OrderController {
    @GetMapping("/orders")
    public String orderList(@ModelAttribute("orderSearch") OrderSearch orderSearch, Model model) {
        List<Order> orders = orderService.findOrders(orderSearch);
        model.addAttribute("orders", orders);

        return "order/orderList";
    }

    @PostMapping("/orders/{orderId}/cancel")
    public String cancelOrder(@PathVariable("orderId") Long orderId) {
        orderService.cancelOrder(orderId);
        return "redirect:/orders";
    }
}
```
