# HTTP 헤더 - 캐시와 조건부 요청

### 캐시가 없을 떄

⇒ 데이터가 변경되지않아도 계속 네트워크를 통해 데이터를 다운로드 받아야한다.

⇒ 인터넷 네트워크는 매우 느리고 비싸다.

⇒ 브라우저 로딩 속도가 느리다.

<br>

### 캐시 적용

⇒ cache-control 를 지정해 캐시가 유효한 시간을 지정해 보내고
    이를 통해 캐시 가능 시간동안은 네트워크를 사용하지않아도 된다.

⇒ 네트워크 사용량을 줄일 수 있다.

⇒ 브라우저 로딩 속도가 매우 빨라진다.

<br>

### 캐시 시간 초과

→ 캐시 시간이 초과되면 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다

→ 이때는 다시 네트워크 다운로드가 발생

<br>

# 캐시 유효 시간이 초과되어 서버에 다시 요청하면 두 가지 상황이 나타난다.

1. 서버에서 기존 데이터를 변경한 상태
2. 서버에서 기존 데이터를 변경하지않은 상태
    
    ⇒ 데이터를 재 전송하는 것보단 저장해둔 캐시를 재사용하는 것이 낫다.
    
    ⇒ 하지만 그렇게 하기위해선 클라이언트의 데이터와 서버의 데이터가 같다는 걸 검증해야한다.
    

<br>


### 검증 헤더 추가

⇒ 첫번째 요청시 캐시에 데이터 최종 수정일을 담아 응답을 보낸다.

⇒ 캐시 시간 초과시 클라이언트가 보낸 캐시의 데이터 최종 수정일과 서버 데이터의 최종 수정일을 확인한다.

⇒ 일치 시 HTTP Body를 전송하지않고 304과 헤더 메타 정보만 응답한다.

⇒ 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시 메타 정보 갱신

⇒ 이후 캐시에서 조회해서 사용 

→ 결과적으로 네트워크 다운로드가 발생하지만 용량이 작은 헤더 정보만 다운로드하기에 실용적

<br>

### 검증 헤더

⇒ 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터

⇒ Last-Modified , ETag

<br>

### 조건부 요청 헤더

→ 검증 헤더로 조건에 따른 분기

→ 조건이 만족하면 200을 조건이 만족하지 않으면 304

<br>

If-Modified-Since

⇒ Last-Modified 사용

⇒ 1초 미만 단위로 캐시 조정이 불가능하다.

⇒ 날짜 기반의 로직을 사용한다

⇒ 데이터를 수정해서 날짜가 다르지만 , 같은 데이터를 수정해서 데이터 결과가 똑같은 경우

⇒ 서버에서 별도의 캐시 로직을 관리하고 싶은 경우

<br>


If-None-Match

⇒ ETag 사용

⇒ 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다.

⇒ 데이터가 변경되면 이 이름을 바꾸어서 변경 + 해시를 다시 생성

⇒ 캐시 제어 로직을 서버에서 완전히 관리한다.


<br>


### 캐시 제어 헤더

1. Cache-Control 캐시 제어
    
    ⇒ 캐시 지시어
    
    ⇒ Cache-Control : max-age [ 캐시 유효 시간 / 초 단위 ]
    
    ⇒ Cache-Control : no-cache [ 데이터는 캐시해도 되지만, 항상 origin 서버에 검증하고 사용 ]
    
    ⇒ Cache-Control : no-store [ 데이터에 민감한 정보가 있으므로 저장하면 안된다. ]
    
2. Pragma 캐시 제어 하위 호환
3. Expires 캐시 제어 하위 호환
    
    ⇒ 캐시 만료일을 정확한 날짜로 지정
    
    ⇒ 더 유연한 cache-Control : max-age를 권장하며 함께 사용하면 expires는 무시된다.
    

<br>


### 프록시 캐시

Cache-Control

1. Cache-Control: public 
    
    - 응답이 public 캐시에 저장 가능
    
2. Cache-Control: private 
    
    - 응답이 해당 사용자 전용이며, private 캐시에 저장해야 함(기본값)
    
3. Cache-Control: s-maxage 
    
    - 프록시 캐시에만 적용되는 max-age
    
4. Age: 60 (HTTP 헤더) 
    
    - 오리진서버에서 응답 후 프록시 캐시에 머문 시간(초)
    

<br>

### 확실한 캐시 무효화 응답

1. Cache-Control: no-cache
    
    ⇒ 데이터는 캐시해도 되지만 항상 origin서버에 검증하고 사용
    
2. Cache-Control: no-store
    
    ⇒ 데이터에 민감한 정보가 있으므로 저장하면 안된다.
    
    ⇒ 메모리에서 사용하고 최대한 빠르게 삭제
    
3. Cache-Control: must-revalidate
    
    ⇒ 캐시 만료 후 최초 조회시 원 서버에서 검증해야한다.
    
    ⇒ origin 서버 접근 실패시 반드시 오류가 발생해야하한다. = 504
    
    ⇒ must-revalidate는 캐시 유효 시간이라면 캐시를 사용
    
4. Pragma: no-cache
